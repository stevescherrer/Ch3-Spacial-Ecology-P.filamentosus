tic
dbstop if error


%%ToDo: Fix location Lon Lat information. Right now this is poorly
%%% See Detection Statistics_KW for information about what tags are viable.
%%implemented. Also kind of cheating and wrong.

%%Building a working matrix (BottomFish) for all individuals with metadata to be the basis of all
%%future code. Also creates Receiver Dates Matrix for cross checking receiver information.
%Output organized By Tag number followed by Detection Date

%%Code stitched together from other projects on 28 Jan 2014
%%Written by Stephen Scherrer

%%All Rights Preserved All Wrongs Traversed

vue_filename = '/Users/stephenscherrer/Dropbox/Lab Folder/Oahu Receiver Data Files/VUE_Export_2015-Jan-20.csv';
receiver_log_filename = '/Users/stephenscherrer/Dropbox/Lab Folder/Oahu Receiver Data Files/DEPLOYMENT_RECOVERY_LOG.csv';
tagging_log_filename = '/Users/stephenscherrer/Dropbox/Lab Folder/Oahu Receiver Data Files/Bottomfish_Tag_Master.csv';

addpath(genpath('/Users/stephenscherrer/Dropbox/Lab Folder/'))



 
%%%%%%%%Building ReceiverDates Matrix%%%%%%%%

%%%FOR BUILDING RECEIVERDATES MATRIX FROM THE 
%RECOVERY LOG
%%WRITTEN 3 JANUARY 2014 IN A COFFEE SHOP IN CAMPBELL BY STEPHEN SCHERRER

%%NOTES: 
%%THIS PROGARM REQUIRES DEPLOYMENT_RECOVERY_LOG.CSV TO BUILD ReceiverDates,
%%A COMMON MATRIX USED IN MANY OTHER CODES. RUN THIS AFTER EVERY DATA
%%DOWNLOAD FROM THE FIELD TO UPDATE DATABASE.

%%NOTES ON OUTPUT FILE:
%%RecieverDates
    %%Column 1=Reciever Location
    %%Column 2=Reciever Number
    %%Column 3=Deployment Date
    %%Column 4=Recovery Date
    %%Column 5=Deployment Latitude (prefix)
    %%Column 6=Deployment Latitude (degree minutes)
    %%Column 7=Deployment Longitude (prefix)
    %%Column 8=Deployment Longitude (degree minutes)
    %%Column 9=Deployment Longitude (decimal degrees)
    %%Column 10=Deployment Latitude (decimal Degrees) 


%% Import detection data from vue csv file.
% Script for importing data from the following text file:
%
%    /Users/stephenscherrer/Dropbox/Lab Folder/Oahu Receiver Data
%    Files/VUE_Export_2014-Oct-8.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2014/10/20 11:06:20

%% Initialize variables.
delimiter = ',';
startRow = 2;

%% Format string for each line of text:
%   column1: datetimes (%{yyyy-MM-dd HH:mm:ss}D)
%	column2: text (%s)
%   column3: text (%s)
%	column4: text (%s)
%   column5: text (%s)
%	column6: text (%s)
%   column7: text (%s)
%	column8: text (%s)
%   column9: text (%s)
%	column10: text (%s)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%{yyyy-MM-dd HH:mm:ss}D%s%s%s%s%s%s%s%s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(vue_filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'EmptyValue' ,NaN,'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
DateandTimeUTC = dataArray{:, 1};
Receiver = dataArray{:, 2};
Transmitter = dataArray{:, 3};
TransmitterName = dataArray{:, 4};
TransmitterSerial = dataArray{:, 5};
SensorValue = dataArray{:, 6};
SensorUnit = dataArray{:, 7};
StationName = dataArray{:, 8};
Latitude = dataArray{:, 9};
Longitude = dataArray{:, 10};

% For code requiring serial dates (datenum) instead of datetime, uncomment
% the following line(s) below to return the imported dates as datenum(s).

% DateandTimeUTC=datenum(DateandTimeUTC);


%% Clear temporary variables
clearvars vue_filename delimiter startRow formatSpec fileID dataArray ans;
%% Import receiver data from receiver .csv file.
% Script for importing data from the following text file:
%
%    /Users/stephenscherrer/Dropbox/Lab Folder/Oahu Receiver Data
%    Files/DEPLOYMENT_RECOVERY_LOG.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2014/10/20 11:08:45

%% Initialize variables.
delimiter = ',';
startRow = 2;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(receiver_log_filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,3,7,8,9,10,11,12,13,19]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end

dateFormatIndex = 1;
blankDates = cell(1,size(raw,2));
anyBlankDates = false(size(raw,1),1);
invalidDates = cell(1,size(raw,2));
anyInvalidDates = false(size(raw,1),1);
for col=[4,5]% Convert the contents of columns with dates to MATLAB datetimes using date format string.
    try
        dates{col} = datetime(dataArray{col}, 'Format', 'MM/dd/yyyy HH:mm', 'InputFormat', 'MM/dd/yyyy HH:mm'); %#ok<SAGROW>
    catch
        try
            % Handle dates surrounded by quotes
            dataArray{col} = cellfun(@(x) x(2:end-1), dataArray{col}, 'UniformOutput', false);
            dates{col} = datetime(dataArray{col}, 'Format', 'MM/dd/yyyy HH:mm', 'InputFormat', 'MM/dd/yyyy HH:mm'); %%#ok<SAGROW>
        catch
            dates{col} = repmat(datetime([NaN NaN NaN]), size(dataArray{col})); %#ok<SAGROW>
        end
    end
    
    dateFormatIndex = dateFormatIndex + 1;
    blankDates{col} = cellfun(@isempty, dataArray{col});
    anyBlankDates = blankDates{col} | anyBlankDates;
    invalidDates{col} = isnan(dates{col}.Hour) - blankDates{col};
    anyInvalidDates = invalidDates{col} | anyInvalidDates;
end
dates = dates(:,[4,5]);
blankDates = blankDates(:,[4,5]);
invalidDates = invalidDates(:,[4,5]);

%% Split data into numeric and cell columns.
rawNumericColumns = raw(:, [1,3,7,8,9,10,11,12,13,19]);
rawCellColumns = raw(:, [2,6,14,15,16,17,18,20,21,22,23,24,25,26,27,28]);


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),rawNumericColumns); % Find non-numeric cells
rawNumericColumns(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
SERVICED = cell2mat(rawNumericColumns(:, 1));
STATION_NO = rawCellColumns(:, 1);
CONSECUTIVE_DEPLOY_NO = cell2mat(rawNumericColumns(:, 2));
DEPLOYMENT_DATE = dates{:, 1};
RECOVERY_DATE = dates{:, 2};
Downloaded = rawCellColumns(:, 2);
IN_DATA_SET = cell2mat(rawNumericColumns(:, 3));
Lat_deg = cell2mat(rawNumericColumns(:, 4));
Lat_min = cell2mat(rawNumericColumns(:, 5));
Lon_deg = cell2mat(rawNumericColumns(:, 6));
Lon_min = cell2mat(rawNumericColumns(:, 7));
BOTTOM_DEPTH = cell2mat(rawNumericColumns(:, 8));
VR2_SERIAL_NO = cell2mat(rawNumericColumns(:, 9));
AR_SERIAL_NO = rawCellColumns(:, 3);
AR_EXPECTED_BATTERY_LIFE = rawCellColumns(:, 4);
AR_VOLTAGE_AT_DEPLOY = rawCellColumns(:, 5);
AR_RELEASE_CODE = rawCellColumns(:, 6);
TempLoggerserial = rawCellColumns(:, 7);
STEVES_ARBITRARY_LOCATION_CODES = cell2mat(rawNumericColumns(:, 10));
DEPLOYED_BYLeadTechnicians = rawCellColumns(:, 8);
RecoveredBy = rawCellColumns(:, 9);
COMMENTS_DEPLOYMENT = rawCellColumns(:, 10);
COMMENTS_RECOVERY = rawCellColumns(:, 11);
VarName24 = rawCellColumns(:, 12);
VarName25 = rawCellColumns(:, 13);
VarName26 = rawCellColumns(:, 14);
VarName27 = rawCellColumns(:, 15);
VarName28 = rawCellColumns(:, 16);

% For code requiring serial dates (datenum) instead of datetime, uncomment
% the following line(s) below to return the imported dates as datenum(s).

% DEPLOYMENT_DATE=datenum(DEPLOYMENT_DATE);
% RECOVERY_DATE=datenum(RECOVERY_DATE);


%% Clear temporary variables
clearvars receiver_log_filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp me dateFormatIndex dates blankDates anyBlankDates invalidDates anyInvalidDates rawNumericColumns rawCellColumns R;

%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/stephenscherrer/Dropbox/Lab Folder/Oahu Receiver Data
%    Files/Bottomfish_Tag_Master.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2014/10/20 11:29:37

%% Initialize variables.
delimiter = ',';
startRow = 2;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(tagging_log_filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[4,5,6,7,8,9,11,13,14,15,16]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end

% Convert the contents of columns with dates to MATLAB datetimes using date
% format string.
try
    dates{2} = datetime(dataArray{2}, 'Format', 'MM/dd/yyyy HH:mm', 'InputFormat', 'MM/dd/yyyy HH:mm');
catch
    try
        % Handle dates surrounded by quotes
        dataArray{2} = cellfun(@(x) x(2:end-1), dataArray{2}, 'UniformOutput', false);
        dates{2} = datetime(dataArray{2}, 'Format', 'MM/dd/yyyy HH:mm', 'InputFormat', 'MM/dd/yyyy HH:mm');
    catch
        dates{2} = repmat(datetime([NaN NaN NaN]), size(dataArray{2}));
    end
end

anyBlankDates = cellfun(@isempty, dataArray{2});
anyInvalidDates = isnan(dates{2}.Hour) - anyBlankDates;
dates = dates(:,2);

%% Split data into numeric and cell columns.
rawNumericColumns = raw(:, [4,5,6,7,8,9,11,13,14,15,16]);
rawCellColumns = raw(:, [1,3,10,12,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]);


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),rawNumericColumns); % Find non-numeric cells
rawNumericColumns(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
ID = rawCellColumns(:, 1);
TaggingDateandTimeUTC = dates{:, 1};
Species = rawCellColumns(:, 2);
Conventional = cell2mat(rawNumericColumns(:, 1));
VemTagType = cell2mat(rawNumericColumns(:, 2));
VemTagno = cell2mat(rawNumericColumns(:, 3));
VemTagCode = cell2mat(rawNumericColumns(:, 4));
VarName8 = cell2mat(rawNumericColumns(:, 5));
FLcm = cell2mat(rawNumericColumns(:, 6));
PCLcm = rawCellColumns(:, 3);
Cohort = cell2mat(rawNumericColumns(:, 7));
Area = rawCellColumns(:, 4);
Capture_Lat_Deg = cell2mat(rawNumericColumns(:, 8));
Capture_Lat_min = cell2mat(rawNumericColumns(:, 9));
Capture_Lon_Degrees = cell2mat(rawNumericColumns(:, 10));
Capture_Lon_min = cell2mat(rawNumericColumns(:, 11));
StomachEverted = rawCellColumns(:, 5);
EyesPopped = rawCellColumns(:, 6);
BladderVented = rawCellColumns(:, 7);
PointofIncision = rawCellColumns(:, 8);
DNAClip = rawCellColumns(:, 9);
Cannulation = rawCellColumns(:, 10);
Sex = rawCellColumns(:, 11);
Video = rawCellColumns(:, 12);
Photo = rawCellColumns(:, 13);
PhotoName = rawCellColumns(:, 14);
AudioLogFile = rawCellColumns(:, 15);
Dropshot = rawCellColumns(:, 16);
TissueSample = rawCellColumns(:, 17);
Gutsample = rawCellColumns(:, 18);
Tagger = rawCellColumns(:, 19);
Notes = rawCellColumns(:, 20);
Recaptured = rawCellColumns(:, 21);
Detections20130713 = rawCellColumns(:, 22);
Comments = rawCellColumns(:, 23);
VarName36 = rawCellColumns(:, 24);
VarName37 = rawCellColumns(:, 25);

% For code requiring serial dates (datenum) instead of datetime, uncomment
% the following line(s) below to return the imported dates as datenum(s).

% TaggingDateandTimeUTC=datenum(TaggingDateandTimeUTC);


%% Clear temporary variables
clearvars tagging_log_filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp me dates blankDates anyBlankDates invalidDates anyInvalidDates rawNumericColumns rawCellColumns R;


%%Begin old Code from V_1.8 Here
    DEPLOYMENT_DATE = datenum(DEPLOYMENT_DATE);
    RECOVERY_DATE = datenum(RECOVERY_DATE);
    DateAdjustment=datenum(2011,8,12)-min(DEPLOYMENT_DATE); %determines date offset from any other date format
    AdjustedDeploymentDates=DEPLOYMENT_DATE+DateAdjustment; %creates new variable with this date adjustment for deployments
    AdjustedRecoveryDates=RECOVERY_DATE+DateAdjustment; %creates new variable with this date adjustment for recoveries
    
    TemporaryReceiverDates=[STEVES_ARBITRARY_LOCATION_CODES,VR2_SERIAL_NO,AdjustedDeploymentDates, AdjustedRecoveryDates, Lat_deg, Lat_min, Lon_deg, Lon_min];
    Addendum=nan(length(TemporaryReceiverDates),2);
    TemporaryReceiverDates=[TemporaryReceiverDates, Addendum];
    
    for i = 1:length(TemporaryReceiverDates);
    if TemporaryReceiverDates(i,5)>1
        TemporaryReceiverDates(i,9)=TemporaryReceiverDates(i,5)+(TemporaryReceiverDates(i,6)./(60));
    else
        TemporaryReceiverDates(i,9)=TemporaryReceiverDates(i,5)-(TemporaryReceiverDates(i,6)./(60));
    end
    if TemporaryReceiverDates(i,7)>1
        TemporaryReceiverDates(i,10)=TemporaryReceiverDates(i,7)+(TemporaryReceiverDates(i,8)./(60));
    else
        TemporaryReceiverDates(i,10)=TemporaryReceiverDates(i,7)-(TemporaryReceiverDates(i,8)./(60));
    end
    end
   
    
    if length(TemporaryReceiverDates)==length(IN_DATA_SET);
        IndexOfReceiversWithData=IN_DATA_SET==1;
        ReceiverDates=TemporaryReceiverDates(IndexOfReceiversWithData,:);
        clear Addendum RECOVERY_DATE DateAdjustment CONSECUTIVE_DEPLOY_NO IndexOfReceiversWithData TemporaryReceiverDates AdjustedDeploymentDates AdjustedRecoveryDates AR_EXPECTED_BATTERY_LIFE AR_RELEASE_CODE AR_SERIAL_NO AR_VOLTAGE_AT_DEPLOY BOTTOM_DEPTH COMMENTS_DEPLOYMENT COMMENTS_RECOVERY CONSECUTIVE_DEPLOYMENTS DEPLOYED_BYLeadTechnician DEPLOYMENT_DATE DEPLOYMENT_TIME DATEADJUSTMENT Downloaded IN_DATA_SET Lat_deg Lon_deg Lat_min Lon_min RD RECOVER_DATE RECOVERY_TIME RecoveredBy SERVICED STATION_NO STEVES_ARBITRARY_LOCATION TempLoggerserial VR2_SERIAL_NO VarName26 VarName27 VarName28 VarName29 VarName30 i;
    else
        disp ('There is a size mismatch between ReceiverDates and IN_DATA_SET vectors. See DEPLOYMENT_AND_RECOVERY_LOG.csv and import for troubleshooting')
    end
   
%%Building a working matrix (BottomFish) for all individuals with metadata to be the basis of all
%%future code. Organized By Tag number followed by Detection Date

%%%%READ ME%%%%

%%%%%Notes on Outputed File
%%%%%Name: BottomFish
    %%Column 1=Tag ID
    %%Column 2=Date&Time
    %%Column 3=Reciever ID
    %%Column 4=Reciever Location (
        %OAHU RECEIVERS
            %1=Haleiwa, 
            %2=Kahuku, 
            %3=Marine Corps Base,
            %4=Makapuu North, 
            %5=Makapuu in BRFA, 
            %6=Makapuu South, 
            %7=Diamond Head,
            %8=SWAC, 
            %9=Barber's Flats, 
            %10=Ko'olina, 
            %11=Power Plant, 
            %12=Waianae,
            %13=Kaena, 
        %Penguin Banks Receivers
            %100=First Finger
            %101=Dropoff Inside
            %102=The Mound
            %103=Pinnacle South
            %104=Base 3rd Finger
            %105=South Tip
        %Cross Seamount Recievers=Receiver numbers 200-210
    %%Column 5=Species (1=Ehu, 2=Opaka, 3=Dogfish, 4=Ges, 5=Kale, 6=Sandbar, 0=unknown)
    %%Column 6=Size (cm)
    %%Column 7=Sex (1=Female, 2=Male, 0=Unknown)
    %%Column 8=(Created in following section)=Presence in BRFA or out of BRFA.
        %%1 indicates individual detected in BAFR, 0 indicates detection outside
        %%BRFA 
    %%Column 9=Date Tag Was Deployed
    %%Column 10=Date Tag is Expected to Die
    %%Column 11=Detection Longitude
    %%Column 12=Detection Latitude

%%%%Clearing unused metadata
 clearvars Area AudioLogFile BladderVented Cannulation Capture_Lat_Deg Capture_Lon_Degrees Capture_Lat_min Capture_Lon_min Cohort Comments Conventional DNAClip Detections20130713 Dropshot EyesPopped Gutsample ID Length Notes PCLcm Photo PhotoName PointofIncision Recaptured Stomach Everted Tagger TissueSample VarName36 VarName37 VemTagType VemTagno VemTagType Video 

%%%%Converting CSV file into a working matrix

%%Converting detection dates to datenumbers
DateTime=DateandTimeUTC;
DateTime=datenum(DateTime);

%%standardizing detection dates to matlab format if in another date format
DateTime(:,1)=DateTime(:,1)+(datenum(2011,08,13,8,38,0)-min(DateTime)); %Assumes minimum value of dataset is 08/13/2011

%%Converting recievers to numbers
TempReceiver=Receiver;
[~,Suffix]=strtok(TempReceiver,'-');
[Rec,~]=strtok(Suffix,'-');

%For some reason Receiver number was brought in as text, this converts back
%to a number so a matrix can be formed.
VR2W=nan(length(Rec),1);

for i = 1:length(Rec)
VR2W(i) = str2double(cell2mat(Rec(i)));
end

clearvars Rec Suffix Hyphen i 

%%Converting TagIDs to relevant part of tag ID (3-5 digit code)
TempTransmitter=Transmitter;
[~,Suffix]=strtok(TempTransmitter,'-');
[~,TagIDWithHyphen]=strtok(Suffix,'-');
[TagsSorted,~]=strtok(TagIDWithHyphen,'-');
TagID=nan(length(TagsSorted),1);

%For some reason TagID was brought in as text, this converts back
%to a number so a matrix can be formed.
for i = 1:length(TagsSorted)
TagID(i) = str2double(cell2mat(TagsSorted(i)));
end

clearvars 'Prefix' 'Suffix' 'SuffixNoHyphen' 'TagIDWithHyphen' 'Hyphen' 'Tags' 'i';

%building matrix for TagID, Detection Date, and Reciever Number
BF=[TagID, DateTime, VR2W];

%%Arranging Data By Tag
[~,Index]=sort(BF(:,1));
Bottomfish=BF(Index,:);

clear BF Index

%%Indexing a list of unique Tag IDs
TagsSorted=unique(Bottomfish(:,1));
TagsSorted=TagsSorted(isnan(TagsSorted)==0); %% I have no idea why this line is necessary.. for some reason the Tag ID list produces a shit ton of NaNs


%%Modifying Detection Times from GMT to HST
Bottomfish(:,2)=Bottomfish(:,2)-0.4167; %%adjusts times from BF file from GMT to HST by subtracting equivilant of 10 hours 

%%Arranging Data by date and time

BottomFish=zeros(size(Bottomfish));
counter=0;

for i=1:length(TagsSorted) %%indexes all Tag IDs
    x=Bottomfish(Bottomfish(:,1)==TagsSorted(i),:); %%Pulls data from master file one ID at a time
    [~,T]=sort(x(:,2));  %%Sorts data by Date/Time and indexes
    sortedBf=x(T,:);
    [H,~]=size(sortedBf);
    for M=1:H;
        counter=counter+1;
        BottomFish(counter,:)=x(M,:); %%Fills in variable BottomFish (note capitalization) with data arranged first by Tag ID, then by date time
    end
end
clearvars i x R T M sortedBf %%Clears variables used in previous loop


%%Determining that previous loop worked
if size(Bottomfish)==size(BottomFish)==1  %%Since BottomFish is the same as Bottomfish but in a different order, if the sizes match, all data was coppied. 
    clear Bottomfish %%therefore unsorted data is deleated
elseif size(Bottomfish)~=size(BottomFish)==1
    disp 'Something Terrible has gone wrong between lines 31 and 36' %%if sizes don't match, spits out where things are iffy
end

BottomFish=BottomFish(BottomFish(:,1)~=37969,:); %%This fish is very dead right next to a receiver.

%%Adding Meta Data

%%Padding matrix for remaining information 
[Y,~]=size(BottomFish);
Addendum=nan(Y,7);
BottomFish=[BottomFish,Addendum];
clear Addendum

%% Determining receiver Longitude and Latitude
[h,~]=size(BottomFish); %indexing length of BottomFish Variable
[R,~]=size(ReceiverDates); %indexing length of ReceiverDates Variable

for i=1:h; %cycles down BottomFish
    for a=1:R; %cycles down ReceiverDates
        if BottomFish(i,3)==ReceiverDates(a,2) && BottomFish(i,2)>ReceiverDates(a,3) && floor(BottomFish(i,2))<=ReceiverDates(a,4); %%if receiver # is the same, detection occurred after receiver deployment and before receiver recovery
           BottomFish(i,4)=ReceiverDates(a,1); %Location for that entry is equivilant to corrosoponding receiver dates entry
           BottomFish(i,11)=ReceiverDates(a,10); %Longitude for that entry is equivilant to corrosponding Longitude for receiver data
           BottomFish(i,12)=ReceiverDates(a,9); %Longitude for that entry is equivilant to corrosponding Longitude for receiver data
        end
    end
end

clearvars h r a i

%Confirming we have a fish in the BRFA
[A,L]=find(BottomFish(:,4)==5);
if A>0;
   disp ('finally found a fish in BRFA!, follow the following fish through the rest of this process')
    L(1)
else
    disp ('No Fish in BRFA. Theres no way this is possible so find fish with tag ID=57445')
end

%%If an detection is in BRFA column 8=1, if outside, column 6=0
for i=1:Y
    if BottomFish(i,4)==5
        BottomFish(i,8)=1;
    elseif BottomFish(i,4)==101
        BottomFish(i,8)=1;
    else
        BottomFish(i,8)=0;
    end
end


clearvars X Y

%Data from Bottomfish_Tag_Master.csv

for i=1:length(BottomFish) 
if BottomFish(i,1)==14412
BottomFish(i,5)=3;
elseif BottomFish(i,1)==37935
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37936
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37937
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37938
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37939
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37940
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37941
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37943
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37944
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37945
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37946
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37948
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37949
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37950
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37951
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37952
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37953
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37954
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37955
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37956
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37957
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37958
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37959
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37960
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37961
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37962
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37963
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37965
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37966
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37967
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37968
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37969
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37970
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37971
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37972
BottomFish(i,5)=4;
elseif BottomFish(i,1)==37973
BottomFish(i,5)=1;
elseif BottomFish(i,1)==37974
BottomFish(i,5)=1;
elseif BottomFish(i,1)==37975
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37976
BottomFish(i,5)=1;
elseif BottomFish(i,1)==37977
BottomFish(i,5)=1;
elseif BottomFish(i,1)==37978
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37979
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37980
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37981
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37982
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37983
BottomFish(i,5)=2;
elseif BottomFish(i,1)==37984
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57445
BottomFish(i,5)=6;
elseif BottomFish(i,1)==57446
BottomFish(i,5)=5;
elseif BottomFish(i,1)==57447
BottomFish(i,5)=1;
elseif BottomFish(i,1)==57448
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57449
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57450
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57451
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57455
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57456
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57457
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57458
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57459
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57460
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57462
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57463
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57464
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57465
BottomFish(i,5)=2;
elseif BottomFish(i,1)==57466
BottomFish(i,5)=2;

 
    
    %%%%%%%%%ADD ANY ADDITIONAL TAGS
end
end


%%Adjusting Sex from string to vector
TempSex1=nan(length(Sex),1); %%This has to be created to convert sex from str to matrix
for i=1:length(Sex)
    if Sex{i}=='F';
        TempSex1(i)=1;
    elseif Sex{i}=='M';
        TempSex1(i)=2;
    else
        TempSex1(i)=0;
    end
end

%%Assigning Sex and Length to each entry of BottomFish
for i=1:length(VemTagCode);
    BottomFish(BottomFish(:,1)==VemTagCode(i,1),7)=TempSex1(i,1);
    BottomFish(BottomFish(:,1)==VemTagCode(i,1),6)=FLcm(i,1);
end

for i=1:length(BottomFish);
    if BottomFish(i,6)==0;
        BottomFish(i,6)=NaN;
    end
end

%%%%Start Added April 28 2014

%Creating TagDate Variable
TaggingDate=(datenum(2012,04,13,14,09,00)-min(datenum(TaggingDateandTimeUTC)))+datenum(TaggingDateandTimeUTC);
TagDate=[VemTagCode, datenum(TaggingDate)];
TagDate = TagDate(isnan(TagDate(:,1))==0, :);
%Creating a 9th and 10th Column for BottomFish Workspace 9th column for Tag Date, 10th for anticipated transmitter death.
Addendum=nan(length(BottomFish),2); %creates additional columns for BottomFish variable
BottomFish=[BottomFish,Addendum]; %adds these variables to Bottomfish matrix
clear Addendum %clears Addendum Variable
%%%Replacing zeros in column 9 of BottomFish with Tagging Date
for i=1:length(TagDate); %indexes previously created TagDate variable
    for b=1:length(BottomFish); %indexes all monitor detections
        if TagDate(i,1)==BottomFish(b,1); %if Tag IDs match
          BottomFish(b,9)=TagDate(i,2); %Tagging Date written to column 9 of BottomFish Variable
        end
    end
end
clear i b;
%%In this project, tags have been coded as follows:

%%Tag Code Range     Average Seconds     Batery life (Days)
%%57371-57470        150                 450
%%37935-37985        180                 539
%%52142-52161        150                 450

%Calculating Tag Death
for i=1:length(BottomFish); %indexes BottomFish matrix
	if BottomFish(i,1)>=57371 && BottomFish(i,1)<=57470;
		BottomFish(i,10)=BottomFish(i,9)+450;
	elseif BottomFish(i,1)>=37935 && BottomFish(i,1)<=37985;
		BottomFish(i,10)=BottomFish(i,9)+539;
	elseif BottomFish(i,1)>=52142 && BottomFish(i,1)<=52161;
		BottomFish(i,10)=BottomFish(i,9)+450;
	end
end

clearvars -except ReceiverDates BottomFish

%removing any duplicates
OahuDatabase=unique(BottomFish, 'rows');


%Breaking Out Tags By Species

Ehu=OahuDatabase(OahuDatabase(:,5)==1,:);
Opakapaka=OahuDatabase(OahuDatabase(:,5)==2,:);
Kalekale=OahuDatabase(OahuDatabase(:,5)==5,:);
%Onaga=OahuDatabase(OahuDatabase(:,5)==___,:);

BottomFish=[Ehu; Opakapaka; Kalekale];
save BottomFish 



%%%%%Notes on Outputed File
%%%%%Name: BottomFish
    %%Column 1=Tag ID
    %%Column 2=Date&Time
    %%Column 3=Reciever ID
    %%Column 4=Reciever Location 
        %OAHU RECEIVERS
            %1=Haleiwa, 
            %2=Kahuku, 
            %3=Marine Corps Base,
            %4=Makapuu North, 
            %5=Makapuu in BRFA, 
            %6=Makapuu South, 
            %7=Diamond Head,
            %8=SWAC, 
            %9=Barber's Flats, 
            %10=Ko'olina, 
            %11=Power Plant, 
            %12=Waianae,
            %13=Kaena, 
            %21=BotCam
        %Penguin Banks Receivers
            %100=First Finger
            %101=Dropoff Inside
            %102=The Mound
            %103=Pinnacle South
            %104=Base 3rd Finger
            %105=South Tip
    %%Column 5=Species (1=Ehu, 2=Opaka, 3=Dogfish, 4=Ges, 5=Kale, 6=Sandbar, NaN=unknown)
    %%Column 6=Size (cm) if=NaN, information Unknown/Unavailable
    %%Column 7=Sex (1=Female, 2=Male, NaN=Unknown/Unavailable)
    %%Column 8=(Created in following section)=Presence in BRFA or out of BRFA.
        %%1 indicates individual detected in BAFR, 0 indicates detection outside
        %%BRFA
    %%Column 9=Date Tag Was Deployed
    %%Column 10=Date Tag is Expected to Die
        
        
%%%%%%%%%%%%%%%%%%%%Version Updates%%%%%%%%%%%%%%%%%%%%%%
%%Updates in V_2.1
    %Moving code to R/Python. New workflow as follows.
%%Updates in V_2.0
    %Code now part of GitHub. Moved all prior revisions to file
    %"WorkingDatabaseForAllCode.m" with revision numbers in summary and
    %comments. Matlab no longer thinks this is a function. 
%%Updates in V_1.9
    %Added automatic importing from file paths.
%%Updates in V_1.8
    %Rewrote code to be a little easier to read/no longer thinks its a
    %function. 
%%Updates in V_1.7
    %%Added Tag date and tag death columns
    %%Updated receiver location indexes
%%Updates in V_1.6
    %%in V_1.5, tried to automatically import data files but this proved
    %%problematic so it has been removed until it can be debugged. Added
    %%code to use tag 37969, which is inside a very dead fish, to look at
    %%temporal differences in receiver detection range
%%Updats in V_1.2
    %%removes the same detections if vue file imported too many times. not
    %%sure how this wasn't done sooner...
%%Updates in v_1.0
    %%Code has been rewritten to eliminate excel data massage. Excel now only
    %%used to compile VUE files into one massive database. This step could
    %%possibly be simplified if all VUE data exported as one huge datadump.
%%Updates in v_0.6
    %corrected location data to reflect actual reciever files
%%Updates in v_0.5
    %added notation for BOTTOMFISHTAGDATA initial file

    
    
    %%%% SILENCE THIS IN THE FUTURE%%%%%
    %% Bottomfish for R analysis on 21 Jan 2015
    % col 1= datenum
    % col 2 = rec
    % col 3 = tag id
    % col 4 = location
    % col 5 = BRFA
    % col 6 = tag date
    % col 7 = tag death
    % col 8 = long
    % col 9 = lat
    % col 10 = ping interval
    Bottom.Fish = [BottomFish(:,2), BottomFish(:,3), BottomFish(:,1), BottomFish(:,4), BottomFish(:,8), BottomFish(:,9), BottomFish(:,10), BottomFish(:,11), BottomFish(:,12)];
    ping_interval = zeros(length(Bottom.Fish),1);
    for i = 1:length(Bottom.Fish);
        if Bottom.Fish(i,3) >= 37935 && Bottom.Fish(i,3)<=37985;
            ping_interval(i) = 180;
        elseif Bottom.Fish(i,3) >= 57371 && Bottom.Fish(i,3) <= 57470;
            ping_interval(i) = 150;
        elseif Bottom.Fish(i,3) >= 52142 && Bottom.Fish(i,3) <= 52161;
            ping_interval(i) = 150;
        end
    end
    
    for i = 1:length(Bottom.Fish)
        if Bottom.Fish(i,3) == 37960;
            Bottom.Fish(i,6) = 735195;
            Bottom.Fish(i,7) = Bottom.Fish(i,6) + 539;
        elseif Bottom.Fish(i,3) == 37970;
            Bottom.Fish(i,6) = 734972.589583333;
            Bottom.Fish(i,7) = Bottom.Fish(i,6) + 539;
        elseif Bottom.Fish(i,3) == 37961;
            Bottom.Fish(i,6) = 735196;
            Bottom.Fish(i,7) = Bottom.Fish(i,6) + 539;
        elseif Bottom.Fish(i,3) == 57455;
            Bottom.Fish(i,6) = 735174;
            Bottom.Fish(i,7) = Bottom.Fish(i,6) + 450;
        elseif Bottom.Fish(i,3) == 57457;
            Bottom.Fish(i,6) = 735174;
            Bottom.Fish(i,7) = Bottom.Fish(i,6) + 450;
        elseif Bottom.Fish(i,3) == 57464;
            Bottom.Fish(i,6) = 735176;
            Bottom.Fish(i,7) = Bottom.Fish(i,6) + 450;
        end
    end

    Bottom.Fish = [Bottom.Fish, ping_interval];
    Bottom.Fish = Bottom.Fish(ping_interval ~= 0, :);
    
    BF_Tag = [37960, 37961, 57455, 57457, 57464];
    BF = [];
    for i = 1:length(BF_Tag);
        BF = [BF; Bottom.Fish(Bottom.Fish(:,3) == BF_Tag(i),:)];
    end
    [V,I] = sort(BF(:,1));
    bfish = BF(I,:);
    start_of_study = datenum(2012, 04, 13); % Earliest tagging date
    Bottom_Fish=Bottom.Fish;
    
    bfish(:,1) = bfish(:,1) - start_of_study;
    bfish(:,7) = bfish(:,7) - start_of_study;
    bfish(:,6) = bfish(:,6) - start_of_study;
    Bottom_Fish(:,1) = Bottom_Fish(:,1) - start_of_study;
    Bottom_Fish(:,7) = Bottom_Fish(:,7) - start_of_study;
    Bottom_Fish(:,6) = Bottom_Fish(:,6) - start_of_study;
    ReceiverDates_tag_stand = ReceiverDates;
    ReceiverDates_tag_stand(:,3) = ReceiverDates_tag_stand(:,3) - start_of_study;
    ReceiverDates_tag_stand(:,4) = ReceiverDates_tag_stand(:,4) - start_of_study;
    

    csvwrite('bottomfish_for_phase_1_analysis_5_tags.csv', bfish)
    csvwrite('receiver_dates.csv', ReceiverDates_tag_stand)
    csvwrite('bottomfish_for_phase_1_analysis_all_tags.csv', Bottom_Fish)
    

toc